/*
 * transport.c 
 *
 * CS244a HW#3 (Reliable Transport)
 *
 * This file implements the STCP layer that sits between the
 * mysocket and network layers. You are required to fill in the STCP
 * functionality in this file. 
 *
 * For testing connection setup and teardown only, run server first in one terminal.
    $ ./server (or ./server -U for the unreliable network mode)
    Server's address is kyoungsoo-PC:42737
    Then, in another terminal on the same machine,
    $ ./client localhost:42737 (or ./client localhost:42737 -U for the unreliable network mode) client>
 */


#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <bits/stdint-uintn.h>
#include "mysock.h"
#include "stcp_api.h"
#include "transport.h"

const int DEFAULT_OFFSET = 5;
const int DEFAULT_WINDOW_SIZE = 3072;
//const int DEFAULT_TIMEOUT = 30;
enum {
    CSTATE_SYN_SENT,
    CSTATE_SYN_RECEIVED,
    CSTATE_ESTABLISHED,
    CSTATE_FIN_WAIT_1,
    CSTATE_FIN_WAIT_2,
    CSTATE_CLOSE_WAIT,
    CSTATE_LAST_ACK,
    CSTATE_CLOSED,
};

/* this structure is global to a mysocket descriptor */
typedef struct {
    bool_t done;    /* TRUE once connection is closed */
    int connection_state;   /* state of the connection (established, etc.) */
    tcp_seq initial_sequence_num;

    /* any other connection-wide global variables go here */

    /* Sliding window variables */
    tcp_seq send_base;      /* Base of the send window */
    tcp_seq next_seq_num;   /* Next sequence number to be sent */
    tcp_seq receive_base;      /* Base of the receive window */
    tcp_seq expected_seq_num; /* Expected sequence number to be received */
} context_t;

struct tcphdr getACKPacket(const context_t *ctx);
struct tcphdr getFINPacket(const context_t *ctx);
static void generate_initial_seq_num(context_t *ctx);
static void control_loop(mysocket_t sd, context_t *ctx);
static void connection_teardown(mysocket_t sd, context_t *ctx);
/**********************************************************************/
void connection_refused(context_t *ctx);
int establish_connection(mysocket_t sd, context_t *ctx, bool_t active);

/* our_dprintf
 *
 * Send a formatted message to stdout.
 *
 * format               A printf-style format string.
 *
 * This function is equivalent to a printf, but may be
 * changed to log errors to a file if desired.
 *
 * Calls to this function are generated by the dprintf amd
 * dperror macros in transport.h
 */
void our_dprintf(const char *format, ...) {
    va_list argptr;
    char buffer[1024];

    assert(format);
    va_start(argptr, format);
    vsnprintf(buffer, sizeof(buffer), format, argptr);
    va_end(argptr);
    fputs(buffer, stdout);
    fflush(stdout);
}


/* initialise the transport layer, and start the main loop, handling
 * any data from the peer or the application.  this function should not
 * return until the connection is closed.
 */
void transport_init(mysocket_t sd, bool_t is_active) {

    context_t *ctx;

    ctx = (context_t *) calloc(1, sizeof(context_t));
    assert(ctx);

    generate_initial_seq_num(ctx);

    // initialize the connection state
    ctx->send_base = ctx->initial_sequence_num;
    ctx->next_seq_num = ctx->initial_sequence_num;
    ctx->receive_base = 0;
    ctx->expected_seq_num = 0;

    // 3 way TCP handshake
    int result = establish_connection(sd, ctx, is_active);
    if (result != 0) {
        connection_refused(ctx);
    }
    /* after the handshake completes, unblock the
    * application with stcp_unblock_application(sd).  you may also use
    * this to communicate an error condition back to the application, e.g.
    * if connection fails; to do so, just set errno appropriately (e.g. to
    * ECONNREFUSED, etc.) before calling the function.
    */
    ctx->connection_state = CSTATE_ESTABLISHED;
    stcp_unblock_application(sd);

    control_loop(sd, ctx);

    connection_teardown(sd, ctx);

    /* do any cleanup here */
    ctx->done = TRUE;
    free(ctx);
    our_dprintf("Connection should be closed\n");
}


int establish_connection(mysocket_t sd, context_t *ctx, bool_t is_active) {
    int result = 0;
    if (is_active) {
        // Active open
        struct tcphdr syn_packet;
        memset(&syn_packet, 0, sizeof(syn_packet));
        syn_packet.th_flags = TH_SYN;
        syn_packet.th_seq = ctx->initial_sequence_num;
        syn_packet.th_off = DEFAULT_OFFSET;
        syn_packet.th_win = DEFAULT_WINDOW_SIZE;
        stcp_network_send(sd, &syn_packet, sizeof(syn_packet), NULL);

        ctx->connection_state = CSTATE_SYN_SENT;

        struct tcphdr syn_ack_packet;
        stcp_wait_for_event(sd, NETWORK_DATA, NULL);
        stcp_network_recv(sd, &syn_ack_packet, sizeof(syn_ack_packet));

        if (syn_ack_packet.th_flags == (TH_SYN | TH_ACK)) {
            struct tcphdr ack_packet;
            memset(&ack_packet, 0, sizeof(ack_packet));
            ack_packet.th_flags = TH_ACK;
            ack_packet.th_seq = ctx->initial_sequence_num + 1;
            ack_packet.th_ack = syn_ack_packet.th_seq + 1;
            ack_packet.th_off = DEFAULT_OFFSET;
            ack_packet.th_win = DEFAULT_WINDOW_SIZE;
            stcp_network_send(sd, &ack_packet, sizeof(ack_packet), NULL);

            ctx->receive_base = syn_ack_packet.th_seq + 1;
            ctx->expected_seq_num = ctx->receive_base;

            ctx->connection_state = CSTATE_ESTABLISHED;
        } else {
            result = ECONNREFUSED;
        }
    } else {
        // Passive open
        ctx->connection_state = CSTATE_CLOSED;

        struct tcphdr syn_packet;
        stcp_wait_for_event(sd, NETWORK_DATA, NULL);
        stcp_network_recv(sd, &syn_packet, sizeof(syn_packet));

        if (syn_packet.th_flags == TH_SYN) {
            struct tcphdr syn_ack_packet;
            memset(&syn_ack_packet, 0, sizeof(syn_ack_packet));
            syn_ack_packet.th_flags = TH_SYN | TH_ACK;
            syn_ack_packet.th_seq = ctx->initial_sequence_num;
            syn_ack_packet.th_ack = syn_packet.th_seq + 1;
            syn_ack_packet.th_off = DEFAULT_OFFSET;
            syn_ack_packet.th_win = DEFAULT_WINDOW_SIZE;
            stcp_network_send(sd, &syn_ack_packet, sizeof(syn_ack_packet), NULL);

            ctx->connection_state = CSTATE_SYN_RECEIVED;

            struct tcphdr ack_packet;
            stcp_wait_for_event(sd, NETWORK_DATA, NULL);
            stcp_network_recv(sd, &ack_packet, sizeof(ack_packet));

            if (ack_packet.th_flags == TH_ACK && ack_packet.th_ack == syn_ack_packet.th_seq + 1) {
                ctx->receive_base = syn_packet.th_seq + 1;
                ctx->expected_seq_num = ctx->receive_base;

                ctx->connection_state = CSTATE_ESTABLISHED;
            } else {
                result = ECONNREFUSED;
            }
        } else {
            result = ECONNREFUSED;
        }
    }
    return result;
}

/* control_loop() is the main STCP loop; it repeatedly waits for one of the
 * following to happen:
 *   - incoming data from the peer
 *   - new data from the application (via mywrite())
 *   - the socket to be closed (via myclose())
 *   - a timeout
 */
static void control_loop(mysocket_t sd, context_t *ctx) {
    assert(ctx);
    while (!ctx->done) {
        unsigned int event;
        /* see stcp_api.h or stcp_api.c for details of this function */
        event = stcp_wait_for_event(sd, ANY_EVENT, NULL);

        if (event & NETWORK_DATA) {
            our_dprintf("Network data\n");
            char buffer[STCP_MSS + sizeof(struct tcphdr)];
            struct tcphdr receive_packet;
            ssize_t receive_length = stcp_network_recv(sd, buffer, sizeof (buffer));
            memcpy(&receive_packet, buffer, sizeof(receive_packet));


            if (receive_length < 0) {
                perror("Failed to receive packet");
                break;
            }

            // Process received packet...
            if (receive_packet.th_flags & TH_FIN) {
                // Handle receiving a FIN packet
                our_dprintf("Received FIN packet\n");
                stcp_fin_received(sd);
                ctx->connection_state = CSTATE_CLOSE_WAIT;
                break;
            } else if (receive_packet.th_flags & TH_ACK) {
                // Handle ACK Packet
                our_dprintf("Received ACK packet for ack num: %d\n", receive_packet.th_ack);
                uint32_t ack_num = receive_packet.th_ack;
                if (ack_num > ctx->send_base) {
                    our_dprintf("HEY I SHOULD DO SOMETHING: ACK num: %d", ack_num);
                    ctx->send_base = ack_num;
                    our_dprintf(" HERE'S WHAT WAS DONE: send base: %d\n", ctx->send_base);
                }
            } else {
                our_dprintf("Data packet\n");
                // send ACK packet
                struct tcphdr ack_packet;
                ack_packet = getACKPacket(ctx);
                stcp_network_send(sd, &ack_packet, sizeof(ack_packet), NULL);
                our_dprintf("ACKed packet with ack num: %d\n", ack_packet.th_ack);

                // Strip packet for data
                char *data = buffer + sizeof(receive_packet);
                size_t data_length = receive_length - sizeof(receive_packet);
//                our_dprintf("data to send: %s\ndata length: %d\n", data, data_length);

                // Pass data to application
                stcp_app_send(sd, data, data_length);

                // Update expected sequence number
                ctx->expected_seq_num += data_length;

            }

        } else if (event & APP_CLOSE_REQUESTED) {
            // Handle application close request (active close)
            our_dprintf("Application close requested\n");
            ctx->connection_state = CSTATE_FIN_WAIT_1;
            break;

        } else if (event & APP_DATA) {
            // receive app data
            our_dprintf("Application data\n");
            char data[STCP_MSS];

            // check if other receive window smaller from other person
            our_dprintf("send base: %d\n", ctx->send_base);
            our_dprintf("next seq num: %d\n", ctx->next_seq_num);
            if (ctx->next_seq_num - ctx->send_base >= (size_t) DEFAULT_WINDOW_SIZE) {
                our_dprintf("Window full, waiting for ACKs\n");
                continue;
            }
            size_t data_length = stcp_app_recv(sd, data, sizeof(data));
            our_dprintf("data received: %s data length: %d\n", data, data_length);

            // construct packet with app data
            struct tcphdr data_packet;
            memset(&data_packet, 0, sizeof(data_packet));
            data_packet.th_seq = ctx->next_seq_num;
            data_packet.th_ack = ctx->expected_seq_num + 1;
            data_packet.th_off = DEFAULT_OFFSET;
            data_packet.th_win = DEFAULT_WINDOW_SIZE;

            // send packet to the network
            ssize_t bytes_sent = stcp_network_send(sd, &data_packet, sizeof(struct tcphdr), data, data_length, NULL);
            our_dprintf("Sent packet with %d bytes\n", bytes_sent);
            our_dprintf("data size: %d\n, data packet size: %d\n", data_length, sizeof(data_packet));
            our_dprintf("tcp header size: %d\n", sizeof(struct tcphdr));

            // update next sequence number
            ctx->next_seq_num += data_length;

        } else {
            our_dprintf("Unexpected event\n");
        }
    }
}

/* Handle the connection teardown process */
void connection_teardown(mysocket_t sd, context_t *ctx) {
    assert(ctx);

    struct tcphdr incoming_packet;
    memset(&incoming_packet, 0, sizeof(incoming_packet));
    struct tcphdr ack_packet;
    struct tcphdr fin_packet;
    if(ctx->connection_state == CSTATE_FIN_WAIT_1) {
        // active close: send the FIN packet
        our_dprintf("Active close\n");
        fin_packet = getFINPacket(ctx);
        stcp_network_send(sd, &fin_packet, sizeof(fin_packet), NULL);

        ctx->next_seq_num++;
        ctx->connection_state = CSTATE_FIN_WAIT_1;

        while (ctx->connection_state != CSTATE_CLOSED) {
            unsigned int event = stcp_wait_for_event(sd, NETWORK_DATA, NULL);

            if (event & NETWORK_DATA) {
                ssize_t receive_length = stcp_network_recv(sd, &incoming_packet, sizeof(incoming_packet));
                if (receive_length < 0) {
                    our_dprintf("Failed to receive packet\n");
//                    break;
                } else if (ctx->connection_state == CSTATE_FIN_WAIT_1 && (incoming_packet.th_flags & TH_ACK)) {
                    our_dprintf("Received ACK\n");
                    ctx->connection_state = CSTATE_FIN_WAIT_2;

                } else if ((ctx->connection_state == CSTATE_FIN_WAIT_2 && (incoming_packet.th_flags & TH_FIN))
                || (ctx->connection_state == CSTATE_FIN_WAIT_1 && (incoming_packet.th_flags & TH_FIN))) {
                    our_dprintf("Received FIN\n");
                    stcp_fin_received(sd);
                    ack_packet = getACKPacket(ctx);
                    stcp_network_send(sd, &ack_packet, sizeof(ack_packet), NULL);
                    ctx->connection_state = CSTATE_CLOSED;
                } else {
                    our_dprintf("Unexpected packet received\n");
                }
            }
        }

    } else if (ctx->connection_state == CSTATE_CLOSE_WAIT) {
        // passive close: received FIN, send ACK

        our_dprintf("Passive close\n");
        ack_packet = getACKPacket(ctx);
        stcp_network_send(sd, &ack_packet, sizeof(ack_packet), NULL);

        ctx->connection_state = CSTATE_CLOSE_WAIT;

        // now send FIN
        fin_packet = getFINPacket(ctx);
        stcp_network_send(sd, &fin_packet, sizeof(fin_packet), NULL);

        ctx->next_seq_num++;
        ctx->connection_state = CSTATE_LAST_ACK;

        while(ctx->connection_state != CSTATE_CLOSED) {
            unsigned int event = stcp_wait_for_event(sd, NETWORK_DATA, NULL);
            if (event & NETWORK_DATA) {
                ssize_t receive_length = stcp_network_recv(sd, &incoming_packet, sizeof(incoming_packet));
                if (receive_length > 0 && (incoming_packet.th_flags & TH_ACK)) {
                    ctx->connection_state = CSTATE_CLOSED;
                }
            }
        }
    }
    // should be redundant if i put it in the transport init
    ctx->done = TRUE;
}

void connection_refused(context_t *ctx) {
    ctx->done = TRUE;
    ctx->connection_state = CSTATE_CLOSED;
    errno = ECONNREFUSED;

    fprintf(stderr, "Connection refused\n");
    // honestly i'm not sure if we need to exit in this case, i don't think so
//    free(ctx);
//    exit(-1);
}

/* generate initial sequence number for an STCP connection */
static void generate_initial_seq_num(context_t *ctx) {
    assert(ctx);
    ctx->initial_sequence_num = 1;
}

struct tcphdr getACKPacket(const context_t *ctx) {
    struct tcphdr ack_packet;
    memset(&ack_packet, 0, sizeof(ack_packet));
    ack_packet.th_flags = TH_ACK;
    ack_packet.th_seq = ctx->next_seq_num;
    ack_packet.th_ack = ctx->expected_seq_num + 1;
    ack_packet.th_off = DEFAULT_OFFSET;
    ack_packet.th_win = DEFAULT_WINDOW_SIZE;
    our_dprintf("ACKing with expected sequence number: %d\n", ack_packet.th_ack);
    return ack_packet;
}

struct tcphdr getFINPacket(const context_t *ctx) {
    struct tcphdr fin_packet;
    memset(&fin_packet, 0, sizeof(fin_packet));
    fin_packet.th_flags = TH_FIN;
    fin_packet.th_seq = ctx->next_seq_num;
    fin_packet.th_off = DEFAULT_OFFSET;
    fin_packet.th_win = DEFAULT_WINDOW_SIZE;
    return fin_packet;
}
